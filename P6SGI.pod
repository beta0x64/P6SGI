=NAME P6SGI - Perl 6 Web Server Gateway Interface Specification

=begin pod

=head1 STATUS

This is a Proposed Draft. Given Version 0.3.Draft so that it has some kind of initial designation.

=head1 0 INTRODUCTION

This document standardizes the interface to be implemented by web application developers in Perl 6. It provides a standard protocol by which application servers may communicate with web applications.

This standard has the following goals:

=item Standardize the interface between server and application so that web developers may focus on application development rather than the nuances of supporting each of several server platforms.

=item Keep the interface simple so that a web application or middleware requires no additional tools or libraries other than what exists in a standard Perl 6 environment.

=item Keep the interface simple so that servers and middleware are simple to implement.

=item Allow the interface to flexible enough to accomodate a variety of common use-cases and simple optimzations.

=item Provide flexibility so that unanticipated use-cases may be implemented and so that the interface may be extended by servers wishing to do so.

Aside from that is the underlying assumption that this is a simple interface and ought to at least somewhat resemble work in the standards it is derived from, including Rack, WSGI, PSGI, and others.

This document is strongly related to the PSGI pecification for Perl 5. Within a Perl 6 environment, it is perfectly acceptable to refer to this standard as "PSGI" with the "6" in "P6SGI" being implied. However, for clarity, P6SGI and PSGI from Perl 5 are quite different because Perl 6 provides a number of built-in tools that greatly simplify several aspects of this specification.

=head1 1 TERMINOLOGY

A D<P6SGI application> is a Perl 6 subroutine that expects to receive an environment form an I<application server> and returns a response each time it is called to be processed by that server.

A D<Web Server> is an application that processes requests and responses according to the HTTP protocol.

An D<application server> is a program that is able to provide an environment to a I<P6SGI application> and process the value returned from such an application.

The I<application server> might be associated with a I<web server>, might itself be a I<web server>, might process a protocol used to communicate with a I<web server> (such as CGI or FastCGI), or may be something else entirely not related to a I<web server> (such as a tool for testing I<P6SGI applications>).

D<Middleware> is a I<P6SGI application> that wraps another I<P6SGI application> for the purpose of performing some auxiliary task such as preprocessing request environments, logging, postprocessing responses, etc.

A D<framework developer> is a developer who writes an I<application server>.

An D<application developer> is a developer who writes a I<P6SGI application>.

=head1 2 SPECIFICATION

This specification is divided into three layers: Layer 0: Server, Layer 1: Middleware, and Layer 2: Application.

=head2 2.0 Layer 0: Server

A P6SGI application server is a program capable of running P6SGI applications as defined by this specification.

=head3 2.0.0 Locating Applications

This aspect of the specification is deliberately vague and left up to the implementation. No requirements are made here.

However, it is recommended that the server be able to load applications found in P6SGI script files. These are Perl 6 code files that end with the definition of a block to be used as the application routine. For example:

    use v6;
    sub app(%env) { 200, [ Content-Type => 'text/plain' ], [ 'Hello World!' ] }

These files typically have an extension of F<.p6w> (Perl 6 Web application files).

=head3 2.0.1 The Environment

The environment MUST be an L<Associative>. The keys of this map are mostly derived the old Common Gateway Interface (CGI) as well as a number of additional P6SGI-specific values. The application server MUST provide each key as the type given.

This list is primarily adopted from L<PSGI|https://metacpan.com/pod/PSGI>.

=begin table :allow<C>

    Variable                 | Constraint                             | Description
    =========================|========================================|======================================
    C<REQUEST_METHOD>        | C<< Str:D where *.chars > 0 >>         | The HTTP request method, such as
                             |                                        | "GET" or "POST".

    C<SCRIPT_NAME>           | C<< Str:D where any('', m{ ^ "/" }) >> | This is the initial prtion of the
                             |                                        | URL path that refers to the
                             |                                        | application.

    C<PATH_INFO>             | C<< Str:D where any('', m{ ^ "/" }) >> | This is the remainder of the request
                             |                                        | URL path within the application.
                             |                                        | This value SHOULD be URI decoded by
                             |                                        | the application server according to
                             |                                        | L<RFC 3875|http://www.ietf.org/rfc/rfc3875>

    C<REQUEST_URI>           | C<< Str:D >>                           | This is the exact URL sent by the
                             |                                        | client in the request line of the
                             |                                        | HTTP request. The application server
                             |                                        | SHOULD NOT perform any decoding on
                             |                                        | it.

    C<QUERY_STRING>          | C<< Str:D >>                           | This is the portion of the requested
                             |                                        | URL following the C<?>, if any.

    C<SERVER_NAME>           | C<< Str:D where *.chars > 0 >>         | This is the server name of the web
                             |                                        | server.

    C<SERVER_PORT>           | C<< Int:D where * > 0 >>               | This is the server port of the web
                             |                                        | server.

    C<SERVER_PROTOCOL>       | C<< Str:D where *.chars > 0 >>         | This is the server protocol sent by
                             |                                        | the client. Typically set to
                             |                                        | "HTTP/1.1" or a similar value.

    C<CONTENT_LENGTH>        | C<< Int:_ >>                           | This corresponds to the
                             |                                        | Content-Length header sent by the
                             |                                        | client. If no such header was sent
                             |                                        | the application server SHOULD set
                             |                                        | this key to the L<Int> type value.

    C<CONTENT_TYPE>          | C<< Str:_ >>                           | This corresponds to the Content-Type
                             |                                        | header sent by the cilent. If no
                             |                                        | such header was sent the application
                             |                                        | server SHOULD set this key to the
                             |                                        | L<Str> type value.

    C<HTTP_*>                | C<< Str:_ >>                           | The remaining request headers are
                             |                                        | placed here. The names are prefixed
                             |                                        | with C<HTTP_>, in ALL CAPS with the
                             |                                        | hyphens ("-") turned to underscores
                             |                                        | ("_"). Multiple incoming headers
                             |                                        | with the same name should be joined
                             |                                        | with a comma (", ") as described in
                             |                                        | L<RFC 2616|http://www.ietf.org/rfc/rfc2616>.
                             |                                        | The C<HTTP_CONTENT_LENGTH> and
                             |                                        | C<HTTP_CONTENT_TYPE> headers MUST
                             |                                        | NOT be set.

    Other CGI Keys           | C<< Str:_ >>                           | The server SHOULD attempt to provide
                             |                                        | as many other CGI variables as
                             |                                        | possible, but no others are required
                             |                                        | or formally specified.

    C<psgi.version>          | C<< Version:D >>                       | This is the version of this
                             |                                        | specification, C<v0.3.Draft>.

    C<psgi.url-scheme>       | C<< Str:D >>                           | Either "http" or "https".

    C<psgi.input>            | Like C<< IO::Handle:_ >>               | The input stream for reading the
                             |                                        | body of the request, if any.

    C<psgi.input.buffered>   | C<< Bool:D >>                          | True if the input stream is buffered
                             |                                        | and seekable.

    C<psgi.errors>           | Like C<< IO::Handle:D >>               | The error stream for logging.

    C<psgi.errors.buffered>  | C<< Bool:D >>                          | True if the error stream is buffered.

    C<psgi.multithread>      | C<< Bool:D >>                          | True if the app may be
                             |                                        | simultaneously invoked in another
                             |                                        | thread in the same
                             |                                        | process.

    C<psgi.multiprocess>     | C<< Bool:D >>                          | True if the app may be simultaneously
                             |                                        | invoked in another process.

    C<psgi.run-once>         | C<< Bool:D >>                          | True if the server expects the app
                             |                                        | to be invoked only once during the
                             |                                        | life of the process. This is not a
                             |                                        | guarantee.

    C<psgi.streaming>        | C<< Bool:D >>                          | True if the server supports deplayed
                             |                                        | response and streaming interfaces.

    C<psgi.encoding>         | C<< Str:D >>                           | Name of the encoding the server will
                             |                                        | use for any strings it is sent.

    C<psgi.output.sent>      | C<< Promise:D >>                       | A vowed Promise that is kept by the
                             |                                        | server when the server is done
                             |                                        | processing the response. It will
                             |                                        | be broken if the server terminates
                             |                                        | processing early.

=end table

In the environment, either C<SCRIPT_NAME> or C<PATH_INFO> must be set to a non-empty string. When C<REQUEST_URI> is "/", the C<PATH_INFO> SHOULD be "/" and C<SCRIPT_NAME> SHOULD be the empty string. C<SCRIPT_NAME> MUST NOT be set to "/".

One thing to note is that the P6SGI keys in the environment have the prefix C<psgi.>, NOT C<p6sgi.>. This nuance is intended to save typing and makes it easier to maintain backwards compatibility to Perl 5 PSGI-style applications. Adding the "6" does not really gain anything.

For those familiar with Perl 5 PSGI, you may want to take care when working with some of these values. A few look very similar, but are subtly different. For example, the setting called "psgix.input.buffered" in that standard is called "psgi.input.buffered" here. A server supporting legacy response types from PSGI MUST provide duplicate keys in the environment for such differences.

The server or the application may store its own data in the environment as well. These keys MUST contain at least one dot, SHOULD be prefixed uniquely.

The following prefixes are reserved for use by this standard:

=item C<psgi.> is for P6SGI core standard environment.

=item C<psgix.> is for P6SGI standard extensions to the environment.

=head3 2.0.2 The Input Stream

The input stream is set in the C<psgi.input> key of the environment. The server MUST provide an object that implements a subset of the methods of L<IO::Handle>. It MAY choose to provide an L<IO::Handle>.

The input stream object provided by the server MUST provide the following methods:

=begin item

read

    method read(Int:D $bytes) returns Blob { ... }

This method MUST be available. This method is given the number of bytes to read
from the input stream and returns a L<Blob> containing up to that many bytes or
a Blob type object if the stream has come to an end.

=end item

=begin item

seek

    method seek(Int:D $offset, Int:D $whence where 0 >= * >= 2) returns Bool { ... }

This method MAY be provided in all cases, but MUST be provided if C<psgi.input.buffered> is set in the environment. Calling this moves the read cursor to byte position C<$offset> relative to C<$whence>, which is one of the following integers:

=item2 C<0>: Seek from the start of the file.

=item2 C<1>: Seek from the current read cursor position.

=item2 C<2>: Seek from the end of the file.

This method returns True on successful seek.

=end item

=head3 2.0.3 The Error Stream

The error stream MUST be given in the environment via C<psgi.errors>. It is also an L<IO::Handle>-like object, used to log application errors. The server SHOULD write these errors to an appropriate log, console, etc. The error stream MAY be an L<IO::Handle>.

The error stream MUST implement the following methods:

=begin item

print

    multi method print(Str:D: $error) returns Bool:D { ... }
    multi method print(*@error) returns Bool:D { ... }

Both multi variants MUST be provided. The slurpy version using C<@error> will concatenate the stringified version of each value given for recording.

Both variants return True on success.

=end item

=begin item

flush

    method flush() returns Bool:D { ... }

This method MUST be provided. It MAY be a no-op, particularly if C<psgi.errors.buffered> is False. It SHOULD flush the error stream buffer. It returns True on success.

=end item

=head3 2.0.4 Application Response

P6SGI applications may respond to the environment in a variety of ways. A P6SGI server MUST be able to process one of these ways. Other variations SHOULD be processed by a P6SGI server. It MAY do so by using the P6SGI Web Application Adapter library. This library can automatically detect the type of response returned by the application and translate it into the canonical form all P6SGI servers support.

Before going into the canonical form and the standard variations, we need to explain the components of an application response. Each application response is parsed in four parts. Here are the parts, with an example from the canonical form given with each.

=item B<Component A: Overall Delivery>. This describes the overall delivery of the response. For example, the A components of the canonical response is that the response must be returned as a L<Promise> that is kept with a 3-element L<Positional> containing Component B: Status Code, Component C: Message Headers, and Component D: Message Body in indexes 0, 1, and 2, respectively. All A components of response variants MUST describe how these three components are delivered.

=item B<Component B: Status Code>. This describes the delivery of the Status Code. The B component of the canonical response is to handle these as an L<Int> directly representing the code. However the B component varies, it must define a mapping back to the HTTP standard status codes.

=item B<Component C: Message Headers>. This component handles the delivery of HTTP message headers. The C component of the canonical response is to handle these as ordered L<Pair>s mapping header name to header value.

=item B<Component D: Message Body>. This component handles the delivery of the HTTP message body. The D component of the canonical response is a L<Supply> which emits one or more L<Str> or L<Blob> objects containing the message body.

These components may vary independent of one another. For example, one A component variation is to return an ordered list (i.e., a L<Positional>) containing the 3 components directly, rather than doing so by keep a L<Promise>. This variation only describes that change and does not restrain how the B, C, and D components may be varied. That said, it is permissible for such a restriction to be made, but that such must be explained. The standard variations do not make any such restrictions.

Any variation to any of these components SHOULD be distinct from the canonical form and a test SHOULD be defined for detecting such. Any custom variations SHOULD be distinct from the other variations as well.

B<Note:> In the following sections, the components will be formally described using the variables C<$response> to represent the object returned from the P6SGI application and C<$B>, C<$C>, and C<$D> to represent the B, C, and D components. (The C<$response> is the A component if the test given for the variation being described passes.)

=head4 2.0.4.0 Canonical Application Response

This describes the canonical application response that all P6SGI servers MUST be able to process.

The canonical application response is a L<Promise>. In canonical form, the Promise is kept by returning a L<Positional> containing 3 elements. The Position will contain 3 elements, respectively,

=item B<Status Code>. This is a standard HTTP status code reported as an integer.

=item B<Positional>. This is an ordered list of L<Pair>s naming the headers the application wishes to put into the response.

=item B<Supply>. This is a L<Supply> object that the application will use to emit the content of the body as L<Str> and L<Blob> objects.o

=head5 2.0.4.0.0 Component A: Promised Positional

The canonical A form is a L<Promise> that is kept with a L<Positional>. The server SHOULD NOT assume that the Promise will always be kept and SHOULD handle a broken Promise as appropriate.

The test to identify the A component of the canoncial form is:

    $response ~~ Promise && $response.result ~~ Positional

The code for finding the remaining components is:

    ($B, $C, $D) = $response.result.list;

=head4 2.0.4.0.1 Component B: Status Code

The application is required to set this to a valid HTTP status code as an integer. The application server MAY attempt to verify the validity of the status code and that the rest of the response is sane.

The test for the canonical B component is:

    $B ~~ Int

=head4 2.0.4.0.2 Component C: Message Header

The canonical C component is given as a L<List> of L<Pair>s, each Pair maps a header name to a header value.

The server SHOULD attempt to pass on all given headers, at least those that are correctly formatted according to relevant HTTP standards. Any additional headers should also be honored, if possible and security allows, etc. The order of headers with different names MAY be preserved, but the order of multiple headers with the same name, relative to one another, MUST be preserved.

If the application is missing headers that are required for the Status Code given or provides headers that are forbidden, the application server SHOULD treat that as a server error.

The server SHOULD examine the L<Content-Type> header for the C<charset> setting. This SHOULD be used to aid in encoding any L<Str> encountered in the Message Body. If the application does not provide a C<charset>, the server MAY choose to add this header itself using the encoding provided in C<psgi.encoding> in the environment.

The server SHOULD consider the L<Content-Length> header. It MAY choose to stop emitting characters to the HTTP client after that many bytes has been written.

The test for the canonical C component is:

    $C ~~ List && $C.all ~~ Pair

=head4 2.0.4.0.3 Component D: Message Body

The canonical D component is given as a L<Supply> that emits L<Blob> and L<Str> objects.

The server should not concern itself with whether the L<Supply> given is on demand or live. If given, it MUST tap the Supply and process each emitted L<Blob> or L<Str>, at least until the L<Content-Length> number of bytes has been reached (if such a header has been given by the application).

The application server SHOULD continue processing emitted values until the Supply is done. The server SHOULD then end the response. If the Supply is quit instead, the server should attempt to handle the error as well as it can. As the header is probably already sent at this point in the processing, this may just mean logging the error for troubleshooting.

When the Supply is done, the server MUST end processing of the message body. At that point, it MUST keep the Promise given to the application in L<psgi.output.sent>.

The application server MAY choose to stop tapping the message body early because the content is longer than the Content-Length header or because the time between messages being emitted is too great or because the overall time processing the message body is too great or for any other reason. When the server stops tapping the Supply, it MUST break the Promise given to the application in L<psgi.output.sent>.

The server SHOULD attempt to pas on the message body when given, unless the request is one identified by the relavant HTTP standards as not having a body. In such a case, the application should not provide a body. If it does, the application server SHOULD treat that as an error.

The test for the canonical D component is:

    $D ~~ Supply

=head4 2.0.4.1 Component A Variations

This specification includes only two variations within the A component, one is the canonical form and the other is a convenient for many applications.

=head5 2.0.4.1.0 Promised Positional (Canonical)

The canonical form is described above.

=head5 2.0.4.1.1 Positional

Rather than return the components as a L<Promise>, a L<Positional> is returned directly in this form.

The test for this is:

    $response ~~ Positional

To find the B, C, and D components, the following code is used:

    ($B, $C, $D) = $response.list;

=head4 2.0.4.2 Component B Variations

No additional variations aside from the canonical form are included in this specification.

=head5 2.0.4.2.0 Int (Canonical)

The canonical form is described above.

=head4 2.0.4.3 Component C Variations

Only the canonical variation is specified her.

=head5 2.0.4.3.0 List of Pairs (Canonical)

The canonical form is described above.

=head4 2.0.4.4 Component D Variations

There are two variations in this specification, including the canonical form and a second convenient form.

=head5 2.0.4.4.0 Supply of Str and Blob (Canonical)

The canoncial form is described above.

=head5 2.0.4.4.1 List of Str and Blob

This variation may be treated the same as the L<Supply> form by using C<from-list> to generate a Supply from this List.

The test for this form is:

    $D ~~ List

=head3 2.0.5 Encoding

It is up to the server how to handle encoded characters given by the client within the headers.

Within the body, however, any L<Str> emitted from the L<Supply> MUST be encoded. If the application has specified a C<charset> with the L<Content-Type> header, the server SHOULD honor that character encoding. If none is given or the server does not honor the L<Content-Type> header, it MUST encode any L<Str> with the encoding named in C<psgi.encoding>.

Any L<Blob> encountered in the body SHOULD be sent on as is, treating the data as plain binary.

=head2 2.1 Layer 1: Middleware

P6SGI middleware is a P6SGI application that wraps another P6SGI application. In some ways it may act as a server, in other ways it may act as an application. Middleware is used to perform any kind of pre-processing, post-processing, or side-effects that might be added onto an application. Possible uses include logging, encoding, validation, security, debugging, routing, interface adaptation, and header manipulation.

For example, in the following snippet C<&mw> is a simple middleware application that adds a custom header:

    my &app = sub (%env) {
        Promise.start({
            200,
            [ Content-Type => 'text/plain' ],
            Supply.from-list([ 'Hello World' ])
        });
    }

    my &mw = sub (%env) {
        Promise.start({
            my @res = callsame.result;
            @res[1].push: (X-P6SGI-Used => 'True');
            @res;
        });
    };

    &app.wrap(&mw);

As with servers, middleware MUST support the canonical application response types and SHOULD support the standard variations. To aid middleware authors in supporting the standard forms, middleware may use the P6SGI Web Application Adapter library.

=head3 2.1.0 Middleware Application

The way middleware is applied to an application varies. There are two basic mechanisms that may be used: the C<wrap> method and the closure method.

=head4 2.1.0.0 Wrap Method

This is the method demonstrated in the example above. Perl 6 provides a handy C<wrap> method which may be used to apply another subroutine as an aspect of the subroutine being wrapped. In this case, the original applicaiton is called using C<callsame> or C<callwith>.

=head2 2.1.0.1 Closure Method

This method resembles that which would normally be used in PSGI, which is to define the middleware using a closure that wraps the application. The downside is that you must make sure that the middleware is treated as the top level application:

    my &mw = sub (%env) {
        Promise.start({
            my @res = app(%env).result;
            @res[1].push: (X-P6SGI-Used => 'True');
            @res;
        });
    };
    &app = &mw;

This example is functionality identical to the example above.

=head3 2.1.1 Environment

Middleware applications SHOULD pass on the complete environment, only modifying the bits required to do their job. Middlware applications MAY add new keys to the environment as a side-effect.

=head3 2.1.2 The Input Stream

Middleware applications reading the input stream SHOULD seek back to the beginning of the stream if it reads from the input stream.

=head3 2.1.3 The Error Stream

See section 2.2.3.

=head3 2.1.4 Application Response

As with an application, middleware MUST return a valid P6SGI response to the server. Middleware that is shared and intended to be used with many apps SHOULD strongly consider using canonical form.

Middlware developers need to be aware that the application may not return a canonical form response. It MUST be able to process canonical form and SHOULD process standard varations.

See 2.2.4 for information on the canonical form and the standard variations.

=head3 2.1.5 Encoding

All the encoding issues in 2.2.5 need to be considered.

In addition, the middleware application SHOULD pass through the message body unchanged when it does not need to work with it. If the middlware application does need to work with the message body, it SHOULD NOT modify the encoding of the body unless necessary. Whenever possible, it SHOULD manipulate L<Str> as L<Str> and L<Blob> as L<Blob>.

=head2 2.2 Layer 2: Application

A P6SGI application is a Perl 6 routine that receives a P6SGI environment and responds to it by returning a response. A P6SGI application may return a response in a number of various forms, one of which is considered the best form (called the "canonical form").

A simple Hello World P6SGI application may be implemented as follows:

    sub app(%env) {
        200, [ Content-Type => 'text/plain' ], [ 'Hello World' ]
    }

A canonical Hello World P6SGI application for the same might be done like this:

    sub app(%env) {
        Promise.start({
            200,
            [ Content-Type => 'text/plain' ],
            Supply.from-list([ 'Hello World' ])
        })
    }

A P6SGI server is only required to support the canonical form. To allow the simple form to be used on any server, an application may use the P6SGI Web Application Adapter library to convert the application into canonical form very easily, while keeping your code clean and simple.

=head3 2.2.0 Defining an Application

The way an application is defined and used by a P6SGI server may vary by server. The specification does not tell servers how to locate an application to run it, so you will need to see the server's documentation for a description of how to do that.

In general, the application is defined in a script file that defines the application subroutine as the final statement in the file (or includes a reference to the application as the final line of the file).

For example, such a file might look like this:

    use v6;
    use MyApp;
    use MyApp::Middleware;
    sub app(%env) {
        200, [ Content-Type => 'text/plain' ], [ 'App' ]
    }
    &app.wrap(&my-middleware);
    &app;

Here we load some libraries from our main application, we define a simple P6SGI app, we apply some middleware, and then end with the reference to our application. This is the typical method by which an application server will load an application.

=head3 2.2.1 The Environment

The one and only argument passed to the application is an L<Associative> containing the environment. The environment variables that MUST be set are defined in section 2.0.1. Additional variables are probably defined by your application server, so please see its documentation for details.

=head3 2.2.2 The Input Stream

During a POST or PUT operation, the client may send along a message body to your application. The application MAY choose to read the body using the input stream provided in the C<psgi.input> key of the environment.

This is an L<IO::Handle>-like object, but might not be an IO::Handle. The application SHOULD NOT check what kind of object it is and just use the object's C<read> and C<seek> methods as needed. These are defined in more detail in section 2.0.2.

=head3 2.2.3 The Error Stream

The application server is required to provide a L<psgi.errors> key with an L<IO::Handle>-like object capable of logging application errors. The application MAY choose to log errors here (or it MAY choose to log them wherever else it likes).

As with the input stream, the server is not required to provide an IO::Handle and the application SHOULD NOT check what kind of object it is, but just use the C<print> and C<flush> methods as defined in section 2.0.3.

=head3 2.2.4 Application Response

The application MUST return a valid P6SGI response to the server. The application SHOULD be sure that response is in canonical form if it wants to be compatible with all P6SGI-compliant servers.

The canonical form response is a L<Promise> that is kept with a 3-element L<Positional> with the following indexes, respectively:

=item B<Status Code>. This is a standard HTTP status code.

=item B<Message Headers>. This is an ordered list of L<Pair>s naming the headers the application wishes to put into the response.

=item B<Message Body>. This is a L<Supply> which emits L<Blob> and L<Str> objects to be sent as the content of the response.

A trivial P6SGI application could be implemented like this in canonical form:

    sub app(%env) {
        Promise.start({
            200,
            [ Content-Type => 'text/plain' ],
            Supply.from-list([ "Hello World" ]),
        });
    }

In addition to this form, other variations are permitted. These variations are described in the following sections.

=head4 2.2.4.0 Direct Positional

Rather than returning a L<Promise> that is kept with a L<Positional>, a P6SGI application MAY return that L<Positional> directly. The rest of the form is the same.

=head4 2.2.4.1 Message Body as List

A second variation that an application MAY provide is a message body as a L<List> of L<Str> and L<Blob> rather than as a L<Supply>. This is slightly shorter than using a L<Supply> and is provided for convenience.

=head3 2.2.5 Encoding

When sending the message body to the server, the application SHOULD prefer to use L<Blob> objects. This allows the application to fully control the encoding of any text being sent.

The application MAY use L<Str>, but this puts the server in charge of encoding the application's text. The server is only required to encode the data according to the encoding specified in the C<psgi.encoding> key of the environment. It may choose to examine the C<charset> of the Content-Type header returned by the application, but it is not required to do so.

Applications SHOULD avoid characters that require text encoding in HTTP headers.

=head1 Changes

=head2 0.3.Draft

 * Splitting the standard formally into layers: Application, Server, and Middleware.
 * Creating a single unified response type required to implement the Server Layer to be a complete P6SGI server.
 * The other response types are put into the category of P6SGIx extensions.
 * Middleware is given a higher priority in this revision and more explanation.
 * The notion of Adapters is added as a kind of Middleware that permits an application implementing any of the P6SGIx extensions to run on any standard P6SGI server.
 * The notion of a Universal Adapter is added to allow an otherwise ignorant P6SGI standard to implement any future P6SGIx extension interface.
 * Section number is added.
 * Added the Changes section.

=head2 0.2.Draft

This second revision eliminates the legacy standard and requires that all P6SGI responses be returned as a L<Promise>. The goal is to try and gain some uniformity in the responses the server must deal with.

=head2 0.1.Draft

This is the first published version. It was heavily influenced by PSGI and included interfaces based on the standard, deferred, and streaming responses of PSGI. Instead of callbacks, however, it used L<Promise> to handle deferred responses and L<Channel> to handle streaming. It mentioned middleware in passing.

=end pod
